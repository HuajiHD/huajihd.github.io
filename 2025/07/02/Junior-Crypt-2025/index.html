<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="TZE0rZyIqLl10trYu3BWBWa1Vmz6HFwhb2OcNEK4u-s" />
     <link rel="shortcut icon" href= /img/huaji.ico >
    <title>
        blog
    </title>
    <meta name="description" content= 歪比歪比 >
    <meta name="keywords" content= Blog,Hexo,Huaji >
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.3.0"></head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-home
 replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            Junior.Crypt.2025 CTF
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h1 id="Junior-Crypt-2025-CTF"><a href="#Junior-Crypt-2025-CTF" class="headerlink" title="Junior.Crypt.2025 CTF"></a>Junior.Crypt.2025 CTF</h1><h2 id="Beginner"><a href="#Beginner" class="headerlink" title="Beginner"></a>Beginner</h2><h3 id="Double-Trouble"><a href="#Double-Trouble" class="headerlink" title="Double Trouble"></a>Double Trouble</h3><p>WjNKdlpHNXZlMlpwY25OMFgzTjBaWEJmYzJWamIyNWtYM04wWlhCOQ&#x3D;&#x3D;</p>
<p>双重base64，签到</p>
<h3 id="Birds-and-Wires"><a href="#Birds-and-Wires" class="headerlink" title="Birds and Wires"></a>Birds and Wires</h3><p>编码图考的比较常见，编码图叫birdsonawire </p>
<h3 id="EXIF"><a href="#EXIF" class="headerlink" title="EXIF"></a>EXIF</h3><p>查看图片exif信息就行了，但网比较卡没显示</p>
<h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><h3 id="Signature-ECDSA"><a href="#Signature-ECDSA" class="headerlink" title="Signature ECDSA"></a>Signature ECDSA</h3><p>脚本一把梭</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从签名中获取的已知值</span></span><br><span class="line">r = <span class="number">0xe37ce11f44951a60da61977e3aadb42c5705d31363d42b5988a8b0141cb2f50d</span></span><br><span class="line">s1 = <span class="number">0xdf88df0b8b3cc27eedddc4f3a1ecfb55e63c94739e003c1a56397ba261ba381d</span></span><br><span class="line">h1 = <span class="number">0x315f5bdb76d078c43b8ac0064e4a0164612b1fce77c869345bfc94c75894edd3</span></span><br><span class="line">s2 = <span class="number">0x2291d4ab9e8b0c412d74fb4918f57580b5165f8732fd278e65c802ff8be86f61</span></span><br><span class="line">h2 = <span class="number">0xa6ab91893bbd50903679eb6f0d5364dba7ec12cd3ccc6b06dfb04c044e43d300</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SECP256k1 曲线的阶 &#x27;n&#x27;</span></span><br><span class="line">n = <span class="number">0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤 1: 使用公式 k = ((h1 - h2) * modInverse(s1 - s2)) % n 计算 k</span></span><br><span class="line">s1_minus_s2 = s1 - s2</span><br><span class="line">h1_minus_h2 = h1 - h2</span><br><span class="line">k = (h1_minus_h2 * <span class="built_in">pow</span>(s1_minus_s2, -<span class="number">1</span>, n)) % n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤 2: 使用公式 d = ((s1*k - h1) * modInverse(r)) % n 计算 d</span></span><br><span class="line">d = ((s1 * k - h1) * <span class="built_in">pow</span>(r, -<span class="number">1</span>, n)) % n</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[*] 恢复出的 nonce k: <span class="subst">&#123;<span class="built_in">hex</span>(k)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[*] 恢复出的私钥 d: <span class="subst">&#123;<span class="built_in">hex</span>(d)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>然后把d换成数值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line">a=<span class="number">0x67726f646e6f7b4d795f707231766174655f6b65795f6630725f45434453417d</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(a))</span><br></pre></td></tr></table></figure>

<h4 id="OTP-with-shift-register"><a href="#OTP-with-shift-register" class="headerlink" title="OTP with shift register"></a>OTP with shift register</h4><p>密码本，解码密文，恢复密钥流，ai一把梭</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件中提供的 LFSR 函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lfsr</span>(<span class="params">state, mask</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;生成一个新比特并更新 LFSR 状态。&quot;&quot;&quot;</span></span><br><span class="line">    bit = (state &amp; <span class="number">1</span>)  <span class="comment"># 获取最低有效位</span></span><br><span class="line">    state = state &gt;&gt; <span class="number">1</span>      <span class="comment"># 右移状态</span></span><br><span class="line">    <span class="keyword">if</span> bit:</span><br><span class="line">        state ^= mask       <span class="comment"># 如果输出比特为 1，则应用反馈掩码</span></span><br><span class="line">    <span class="keyword">return</span> state, bit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 来自 OTP_LFSR_b64.bin 的 Base64 编码密文</span></span><br><span class="line">b64_ciphertext = <span class="string">&quot;vOALn6jMkGzJb28s6aPrn1AAU1hkczys29kgWML9F7Lch3XpmfyHAV0K+4s4kHH1cQNfwqalv3eLWvHTXFPl7JxCVz1VtFWeaRcHvaWV1jVvHzORQULYpeAvL7P9Cms18+49kc7gRwxuOoTjqlu0xj2Wgo40Loybw1LkksbsPNyffSOcoWOUWx8sb/j4czUdF78XFWRuWrUIC+0RZ1CQSzq/Sz+9zISrAK5+kJurxZoJ43dGc26Maz8D0GABBidUAAMIwQrnNZMbAZOLvZUpeCXMp68YqhH3R2XBx+mE5exdYceEJuxynGfsg3DvBXYnxF6zq+9upqM/LG6fVxNLPrhcn55B6fULln13cHE9RM+DxYCbZncYTJWDT5/9HK170eMBS8UWtP227RKNH+w1B4g4EiZLcnhmw88y6LXKawODpekHlTzkgwKutyVe+bg9dqsv9qflhhIjVHZzGcgNAwZkALaBb+iBYg+jRX21M8lOtN3JeVeWxezgWJinH1LcxQM8k1R7c+HIXGUwSzwlnJEghoxbJK40m4YBo3mBnbUKFo0ZAZXGTao8I5OcZvyAiF0Q4RgO31Atrvh1gadot4Tg/6LIGUe3rt7wyyUZuMldqlNn+Ef2DdNaVyaHMzSptXDn9p9yf61v46Q6TM3BI7PQf6ZXV4EsWFYDlLydhAwhwty+A251+r4BeMUrUdjd&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 Base64 解码密文</span></span><br><span class="line">ciphertext = base64.b64decode(b64_ciphertext)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 已知的 LFSR 参数</span></span><br><span class="line">initial_state = <span class="number">0b1100101011110001</span>  <span class="comment"># 16 位初始状态</span></span><br><span class="line">mask          = <span class="number">0b1011010000000001</span>  <span class="comment"># 16 位反馈掩码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -- 步骤 1: 生成完整的密钥流 --</span></span><br><span class="line">keystream = <span class="built_in">bytearray</span>()</span><br><span class="line">current_state = initial_state</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为密文的每一个字节都生成一个密钥字节</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ciphertext)):</span><br><span class="line">    key_byte = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 为一个字节生成 8 个比特</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        current_state, bit = lfsr(current_state, mask)</span><br><span class="line">        <span class="comment"># 将比特组合成字节 (最高有效位优先)</span></span><br><span class="line">        key_byte |= (bit &lt;&lt; (<span class="number">7</span> - i))</span><br><span class="line">    keystream.append(key_byte)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -- 步骤 2: 通过异或操作解密 --</span></span><br><span class="line">plaintext = <span class="built_in">bytearray</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ciphertext)):</span><br><span class="line">    plaintext.append(ciphertext[i] ^ keystream[i])</span><br><span class="line"></span><br><span class="line"><span class="comment"># -- 步骤 3: 打印结果 --</span></span><br><span class="line"><span class="comment"># 预期输出是文本，所以我们用 UTF-8 解码</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;解密成功! ✔️&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;--- 解密后的明文 ---&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(plaintext.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h3 id="Very-Obfuscated-Crypto"><a href="#Very-Obfuscated-Crypto" class="headerlink" title="Very Obfuscated Crypto"></a>Very Obfuscated Crypto</h3><p>也是一把梭</p>
<h3 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h3><p>要解密希尔密码，我们必须逆转加密过程。</p>
<p>经典的密码学算法， <strong>希尔密码 (Hill Cipher)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># --- 从原始脚本中去混淆的函数 ---</span><br><span class="line"></span><br><span class="line">MODULUS = 257</span><br><span class="line"></span><br><span class="line">def invert_matrix_mod(matrix, mod):</span><br><span class="line">    &quot;&quot;&quot;计算矩阵的模逆元。&quot;&quot;&quot;</span><br><span class="line">    det = int(round(np.linalg.det(matrix)))</span><br><span class="line">    det_inv = pow(det, -1, mod)</span><br><span class="line">    </span><br><span class="line">    # 伴随矩阵等于 det(A) * A_inv</span><br><span class="line">    adjugate_matrix = np.round(det * np.linalg.inv(matrix)).astype(int)</span><br><span class="line">    </span><br><span class="line">    # 模逆矩阵等于 (det_inv * adjugate) % mod</span><br><span class="line">    inverse_matrix = (det_inv * adjugate_matrix) % mod</span><br><span class="line">    return inverse_matrix.astype(int)</span><br><span class="line"></span><br><span class="line"># --- 题目中的数据 ---</span><br><span class="line"></span><br><span class="line"># 密钥矩阵 A</span><br><span class="line">A = np.array([[193, 243, 218], [240, 186, 172], [62, 118, 70]])</span><br><span class="line"></span><br><span class="line"># 加密后的密文矩阵 C</span><br><span class="line">encrypted_matrix = np.array([[76, 252, 109], [67, 73, 222], [227, 49, 104], [199, 230, 167], [118, 74, 4], [253, 70, 40], [78, 123, 230], [16, 240, 85], [62, 184, 34], [87, 50, 233], [224, 188, 40]])</span><br><span class="line"></span><br><span class="line"># --- 解密逻辑 ---</span><br><span class="line"></span><br><span class="line"># 1. 计算 A 的模逆矩阵</span><br><span class="line">A_inv = invert_matrix_mod(A, MODULUS)</span><br><span class="line"></span><br><span class="line"># 2. 计算逆矩阵的转置</span><br><span class="line">A_inv_T = A_inv.T</span><br><span class="line"></span><br><span class="line"># 3. 用 C 乘以转置后的逆矩阵进行解密</span><br><span class="line">decrypted_matrix = (encrypted_matrix @ A_inv_T) % MODULUS</span><br><span class="line"></span><br><span class="line"># 4. 将结果数值矩阵转换回字节</span><br><span class="line">decrypted_bytes = decrypted_matrix.flatten().astype(np.uint8).tobytes()</span><br><span class="line"></span><br><span class="line"># 5. 从末尾移除填充的空字节以获得 flag</span><br><span class="line">flag = decrypted_bytes.rstrip(b&#x27;\x00&#x27;)</span><br><span class="line"></span><br><span class="line">print(&quot;解密成功! ✔️&quot;)</span><br><span class="line">print(f&quot;恢复的 Flag: &#123;flag.decode()&#125;&quot;)</span><br></pre></td></tr></table></figure>



<h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><h3 id="Hybrid-Encryption"><a href="#Hybrid-Encryption" class="headerlink" title="Hybrid Encryption"></a>Hybrid Encryption</h3><p>ai一把梭</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从挑战代码中获取的目标Base64密文</span></span><br><span class="line">encrypted_b64 = <span class="string">&quot;np2Z3p2c3s6YmZ3ezs2ZmM/Tnc7NmJmdz5yYm96cz8+Ym53Z3w==&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 固定的异或密钥</span></span><br><span class="line">XOR_KEY = <span class="number">0xAA</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    执行解密步骤并打印flag</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[*] 目标密文: <span class="subst">&#123;encrypted_b64&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 1. Base64解码，得到被异或加密的字节</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        encrypted_bytes = base64.b64decode(encrypted_b64)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[*] Base64解码成功...&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[!] Base64解码失败: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 再次与密钥0xAA进行异或，恢复原始字节</span></span><br><span class="line">    decrypted_chars = []</span><br><span class="line">    <span class="keyword">for</span> byte <span class="keyword">in</span> encrypted_bytes:</span><br><span class="line">        decrypted_char_code = byte ^ XOR_KEY</span><br><span class="line">        decrypted_chars.append(decrypted_char_code)</span><br><span class="line">    </span><br><span class="line">    decrypted_middle = <span class="built_in">bytes</span>(decrypted_chars).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[*] 异或解密成功...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 拼接成完整的flag</span></span><br><span class="line">    final_flag = <span class="string">f&quot;grodno&#123;&#123;<span class="subst">&#123;decrypted_middle&#125;</span>&#125;&#125;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n✅ 解密完成！&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[*] Flag: <span class="subst">&#123;final_flag&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行解密程序</span></span><br><span class="line">solve()</span><br><span class="line"><span class="comment">#grodno&#123;473t76td237tdg32ey7dg237e621t6ee217su&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="Dynamic-Key"><a href="#Dynamic-Key" class="headerlink" title="Dynamic Key"></a>Dynamic Key</h3><p>根据时间加密的，但是还是可以爆破</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># 目标密文</span><br><span class="line">expected = b&#x27;\x74\xab\x9a\x62\x95\x6b\x9f\x81\x6b\x87\xbd\x99\x81\xb9\x93\x98\xb5\x80\x8d\xa9\x5b\x4a\xb1\x8e\xac\xa7\x9c\xb9\xa9\xa4\xa8\xb1\x39\xdc\xd7\x26\xd5\xea\xee\xdb\xc8\xc7\xca\xf5\x39\xc8\xc0\xcb&#x27;</span><br><span class="line"></span><br><span class="line">def decrypt(encrypted_bytes: bytes, key: int) -&gt; bytes:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    执行加密的逆运算</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    decrypted_chars = []</span><br><span class="line">    for i, c in enumerate(encrypted_bytes):</span><br><span class="line">        # 1. 逆转异或操作 (XOR)</span><br><span class="line">        temp_val = c ^ (i * 2)</span><br><span class="line">        # 2. 逆转加法操作 (注意处理字节回绕)</span><br><span class="line">        original_char_code = (temp_val - key) % 256</span><br><span class="line">        decrypted_chars.append(original_char_code)</span><br><span class="line">    return bytes(decrypted_chars)</span><br><span class="line"></span><br><span class="line"># 暴力破解密钥 (0-127)</span><br><span class="line">for potential_key in range(128):</span><br><span class="line">    decrypted_middle = decrypt(expected, potential_key)</span><br><span class="line">    </span><br><span class="line">    # 尝试将解密结果解码为ASCII。如果成功且所有字符都可打印，</span><br><span class="line">    # 那么我们就找到了正确的密钥。</span><br><span class="line">    try:</span><br><span class="line">        decoded_middle = decrypted_middle.decode(&#x27;ascii&#x27;)</span><br><span class="line">        if all(c.isprintable() for c in decoded_middle):</span><br><span class="line">            # 找到正确的密钥和flag</span><br><span class="line">            print(f&quot;✅ 密钥破解成功!&quot;)</span><br><span class="line">            print(f&quot;[*] Key: &#123;potential_key&#125;&quot;)</span><br><span class="line">            </span><br><span class="line">            # 组装完整的flag</span><br><span class="line">            final_flag = f&quot;grodno&#123;&#123;&#123;decoded_middle&#125;&#125;&#125;&quot;</span><br><span class="line">            print(f&quot;[*] Flag: &#123;final_flag&#125;&quot;)</span><br><span class="line">            </span><br><span class="line">    except UnicodeDecodeError:</span><br><span class="line">        # 如果解码失败，说明密钥错误，继续尝试下一个</span><br><span class="line">        continue</span><br></pre></td></tr></table></figure>

<p>需要在输出里面找明文</p>
<h3 id="Reverse-Puzzle"><a href="#Reverse-Puzzle" class="headerlink" title="Reverse Puzzle"></a>Reverse Puzzle</h3><p>ai一把梭</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 目标字符串，即经过5次变换后的结果</span></span><br><span class="line">final_str = <span class="string">&#x27;789603251257384214725442633&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">unpuzzle_one_step</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    执行一次puzzle函数的逆操作。</span></span><br><span class="line"><span class="string">    它将字符串的前半部分和后半部分重新交错。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="comment"># 计算分割点。对于奇数长度，前半部分会多一个字符。</span></span><br><span class="line">    <span class="comment"># 这与puzzle函数中偶数位字符总是比奇数位多（或相等）相对应。</span></span><br><span class="line">    mid_point = (n + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    first_half = s[:mid_point]</span><br><span class="line">    second_half = s[mid_point:]</span><br><span class="line">    </span><br><span class="line">    original_chars = []</span><br><span class="line">    <span class="comment"># 像拉链一样将两部分交错合并</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(second_half)):</span><br><span class="line">        original_chars.append(first_half[i])</span><br><span class="line">        original_chars.append(second_half[i])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果总长度是奇数，前半部分会多出一个字符，追加到末尾</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(first_half) &gt; <span class="built_in">len</span>(second_half):</span><br><span class="line">        original_chars.append(first_half[-<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(original_chars)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 主解密逻辑 ---</span></span><br><span class="line"><span class="comment"># 初始状态是目标字符串</span></span><br><span class="line">current_str = final_str</span><br><span class="line"><span class="comment"># 执行5次逆向操作</span></span><br><span class="line">num_steps = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[*] 初始目标字符串: <span class="subst">&#123;current_str&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_steps):</span><br><span class="line">    current_str = unpuzzle_one_step(current_str)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[*] 第 <span class="subst">&#123;i+<span class="number">1</span>&#125;</span> 次逆向操作后: <span class="subst">&#123;current_str&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最终得到的字符串就是flag的中间部分</span></span><br><span class="line">middle_part = current_str</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拼接成完整的flag</span></span><br><span class="line">final_flag = <span class="string">f&quot;grodno&#123;&#123;<span class="subst">&#123;middle_part&#125;</span>&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n✅ 解密完成！&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[*] Flag: <span class="subst">&#123;final_flag&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="Compiled-Python"><a href="#Compiled-Python" class="headerlink" title="Compiled Python"></a>Compiled Python</h3><p>题目先是python反编译，所以要先用pyinstxtractor.py，然后对pyc反编译发现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line">password = <span class="string">&#x27;th1s_1s_n0t_th3_p4ssw0rd_I_sw3ar&#x27;</span></span><br><span class="line">enteredPassword = <span class="built_in">input</span>(<span class="string">&#x27;Enter password: &#x27;</span>)</span><br><span class="line">flag = <span class="string">&#x27;grodno&#123;&#x27;</span> + sha256(enteredPassword.encode()).hexdigest()[:<span class="number">32</span>] + <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(enteredPassword) == <span class="built_in">len</span>(password) <span class="keyword">and</span> enteredPassword == password:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;You are right!&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>

<p>所以我们写脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"></span><br><span class="line"><span class="comment"># 程序中硬编码的正确密码</span></span><br><span class="line">password = <span class="string">&#x27;th1s_1s_n0t_th3_p4ssw0rd_I_sw3ar&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 对密码进行SHA256哈希计算</span></span><br><span class="line">full_hash = sha256(password.encode()).hexdigest()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 取哈希值的前32个字符</span></span><br><span class="line">hash_fragment = full_hash[:<span class="number">32</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 组合成最终的flag</span></span><br><span class="line">flag = <span class="string">&#x27;grodno&#123;&#x27;</span> + hash_fragment + <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;✅ Flag计算完成!&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment">#grodno&#123;88ce08dee4f5c6c9a2188d49fd3e9fdd&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Little-warm-up"><a href="#Little-warm-up" class="headerlink" title="Little warm-up"></a>Little warm-up</h3><p>ida打开，反编译发现大概内容是计算一个数值输入进去的sha256为63f907ed0c04f2fe1936c0caca8cafd1105216d91aab062dc8b99539d17e8849，扔到<a target="_blank" rel="noopener" href="https://iotools.cloud/zh/tool/sha256-decrypt/">https://iotools.cloud/zh/tool/sha256-decrypt/</a></p>
<p>解密得到p8a8s8s8w8o8r8d8，去程序里面跑一下就获得flag了</p>

    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <p><h4>版权所有 © 2020 | 作者: Huaji | 主题 By <a class="theme-author" target="_blank" rel="noopener" href="https://github.com/Xunzhuo/hexo-theme-coder" style="font-size:14px; color: #969696">Coder</a></h4>
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span id="busuanzi_container_site_pv">本站浏览总访问量: <span id="busuanzi_value_site_pv"></span></span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_uv">本站访问人数: <span id="busuanzi_value_site_uv"></span></span>
    
    <label class="el-switch el-switch-blue el-switch-sm" style="vertical-align: sub;">
        <input type="checkbox" name="switch" id="update_style">
        <span class="el-switch-style"></span>
    </label>

    <!--         <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
    document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script> -->
</p>
</div>

<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="">
<input type="hidden" id="valine_appKey" value="">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
color: #698fca;
}
.v .vlist .vcard .vhead .vsys {
color: #3a3e4a;
}
.v .vlist .vcard .vh .vmeta .vat {
color: #638fd5;
}
.v .vlist .vcard .vhead .vnick {
color: #6ba1ff;
}
.v a {
color: #8696b1;
}
.v .vlist .vcard .vhead .vnick:hover {
color: #669bfc;
}
</style>
    <script type="text/javascript" color="173,174,173" opacity='1' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
